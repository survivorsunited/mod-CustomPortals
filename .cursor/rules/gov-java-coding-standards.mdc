---
alwaysApply: true
---

# Java Coding Standards for Minecraft Fabric Mod

## General Standards
- Use Java 21 features and syntax
- Follow Minecraft/Fabric naming conventions
- Use proper package structure: `com.example.modid` or `org.yourorg.mods.modname`
- Implement `ModInitializer` interface for main mod class

## Fabric-Specific Guidelines
- Use `net.fabricmc.api.ModInitializer` for mod entry point
- Use `org.slf4j.Logger` for logging (not `System.out.println`)
- Use `net.minecraft.util.Identifier` for resource locations
- Use `net.minecraft.recipe.Ingredient` for recipe ingredients
- Register items, blocks, and entities properly with registries

## Code Organization
- Keep mod logic simple and focused
- Use JSON recipes when possible instead of custom Java classes
- Log initialization and important events
- Follow Minecraft's existing code patterns
- Separate client and server code appropriately
- Use interfaces for API exposure

## Package Structure
```
com.example.mymod/
├── MyMod.java              // Main mod class
├── init/                   // Initialization classes
│   ├── ModItems.java
│   ├── ModBlocks.java
│   └── ModRecipes.java
├── items/                  // Custom item classes
├── blocks/                 // Custom block classes
├── client/                 // Client-only code
└── util/                   // Utility classes
```

## Example Structure
```java
package com.example.mymod;

import net.fabricmc.api.ModInitializer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MyMod implements ModInitializer {
    public static final String MOD_ID = "mymod";
    public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);

    @Override
    public void onInitialize() {
        LOGGER.info("Initializing {} mod", MOD_ID);
        
        // Initialize items, blocks, etc.
        ModItems.register();
        ModBlocks.register();
        ModRecipes.register();
    }
}
```

## Best Practices
- Use constants for mod ID and other repeated strings
- Handle null checks and edge cases
- Document public APIs with Javadoc
- Use meaningful variable and method names
- Follow single responsibility principle
- Minimize mixin usage when possible

## Custom Portals Mod Specific Standards

### Code Style
- Use proper indentation (tabs as shown in existing code)
- Follow existing naming conventions
- Add meaningful comments for complex logic
- Use proper Java logging with LOGGER.info() or LOGGER.debug()
- Package: `dev.custom.portals.*`

### Minecraft Fabric Specific
- Main class: `CustomPortals` implements `ModInitializer` and `WorldComponentInitializer`
- Client class: `CustomPortalsClient` for client-side initialization
- Use `Identifier.of("customportals", "name")` for resource identifiers
- Register blocks/items using Fabric registries: `Registry.register(Registries.BLOCK, ...)`
- Use Cardinal Components API for world data storage
- Use YACL (Yet Another Config Lib) for configuration management

### Portal System Patterns
```java
// Portal data storage using Cardinal Components
public static final ComponentKey<BasePortalComponent> PORTALS = ComponentRegistryV3.INSTANCE
    .getOrCreate(Identifier.of("customportals:portals"), BasePortalComponent.class);

// Portal registration
CustomPortal portal = new CustomPortal(frameId, dimensionId, color, spawnPos, blocks, offsetX, offsetZ, creatorId);
```

### Registry Pattern
```java
// Block registration
Registry.register(Registries.BLOCK, Identifier.of(MOD_ID, "name"), block);
Registry.register(Registries.ITEM, Identifier.of(MOD_ID, "name"), new BlockItem(block, new Item.Settings()));

// Item registration
Registry.register(Registries.ITEM, Identifier.of(MOD_ID, "name"), item);
```

### Configuration Pattern
- Use YACL annotations for config UI generation
- `@AutoGen(category = "category_name")` - Category grouping
- `@Boolean`, `@IntField`, `@EnumCycler()` - Field types
- `@SerialEntry(comment = "...")` - Documentation
- Access config via `CPSettings.instance()`

### Error Handling
- Always check if blocks/items exist before accessing
- Use proper exception handling for mod initialization
- Log errors appropriately with LOGGER.error()
- Handle missing world components gracefully

### Testing
- Test portal creation and linking
- Verify teleportation works correctly
- Test configuration changes
- Verify rune effects (haste, gate, enhancer, infinity)
- Test both client and server functionality
description:
globs:
alwaysApply: false
---
